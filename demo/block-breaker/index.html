<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Block Breaker with Power-Up Icons and Stages</title>
<style>
  body { margin:0; background:#111; display:flex; justify-content:center; align-items:center; height:100vh; }
  canvas { background:#071025; display:block; border:2px solid #26313a; box-shadow:0 10px 30px rgba(0,0,0,0.6); }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = 900;
canvas.height = 600;

let score = 0;
let lives = 3;
let stage = 1;
let gameOver = false;

let rightPressed = false;
let leftPressed = false;
let gameStarted = false;

const DEFAULT_PADDLE_WIDTH = 120;
let paddleHeight = 15;
let paddleWidth = DEFAULT_PADDLE_WIDTH;
let paddleX = (canvas.width - paddleWidth) / 2;
let paddleY = canvas.height - paddleHeight - 18;
let paddleSpeed = 8;

let balls = [];
function createBall(active=false){ return { x: canvas.width/2, y: paddleY - 12, dx: 4*(Math.random()>0.5?1:-1), dy:-4, radius:8, active }; }
balls.push(createBall(false));

const brickRowCount = 6;
const brickColumnCount = 11;
const brickWidth = 66;
const brickHeight = 22;
const brickPadding = 10;
const brickOffsetTop = 60;
const brickOffsetLeft = 36;

const POWER_UP_TYPES = { MULTI_BALL:"multi", BIG_PADDLE:"bigPaddle", THROUGH_BALL:"through", SLOW_BALL:"slow" };
const POWER_UP_ICONS = { [POWER_UP_TYPES.MULTI_BALL]:"‚≠ê", [POWER_UP_TYPES.BIG_PADDLE]:"‚ûï", [POWER_UP_TYPES.THROUGH_BALL]:"‚ö°", [POWER_UP_TYPES.SLOW_BALL]:"üê¢" };

let bricks = [];
function initBricks() {
  bricks = [];
  for(let c=0;c<brickColumnCount;c++){
    bricks[c]=[];
    for(let r=0;r<brickRowCount;r++){
      const hasPU = Math.random()<0.22;
      const types = Object.values(POWER_UP_TYPES);
      const puType = hasPU ? types[Math.floor(Math.random()*types.length)] : null;
      bricks[c][r]={x:0,y:0,status:1,powerUp:puType};
    }
  }
}
initBricks();

let fallingPowerUps=[];
function spawnPowerUp(x,y,type){ fallingPowerUps.push({x,y,dy:1.6+Math.random()*1.6,type}); }

let bigPaddleActive=false, throughBallActive=false, slowBallActive=false;
let effectTimers={big:0,through:0,slow:0};
const EFFECT_DURATION=8000;

document.addEventListener("keydown",(e)=>{ if(e.code==="ArrowRight") rightPressed=true; if(e.code==="ArrowLeft") leftPressed=true; if(e.code==='Space'){ startGame(); } });
document.addEventListener("keyup",(e)=>{ if(e.code==="ArrowRight") rightPressed=false; if(e.code==="ArrowLeft") leftPressed=false; });

function startGame(){ if(!gameStarted && !gameOver){ gameStarted=true; balls.forEach(b=>b.active=true); } else balls.forEach(b=>{ if(!b.active) b.active=true; }); }

function drawScore(){ ctx.font="20px Inter, Arial"; ctx.fillStyle="#e6eef8"; ctx.fillText("Score: "+score,18,28); ctx.fillText("Lives: "+lives,18,50); ctx.fillText("Stage: "+stage,18,72); }
function drawPaddle(){ ctx.fillStyle="#9ee7c5"; roundRect(ctx,paddleX,paddleY,paddleWidth,paddleHeight,6); ctx.fill(); }
function drawBall(ball){ ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.radius,0,Math.PI*2); ctx.fillStyle=throughBallActive?"#ffd166":"#7cc3ff"; ctx.fill(); ctx.closePath(); }
function drawBricks(){ ctx.font="16px Arial"; ctx.textAlign="center"; ctx.textBaseline="middle"; for(let c=0;c<brickColumnCount;c++){ for(let r=0;r<brickRowCount;r++){ const b=bricks[c][r]; if(b.status===1){ const brickX=c*(brickWidth+brickPadding)+brickOffsetLeft; const brickY=r*(brickHeight+brickPadding)+brickOffsetTop; b.x=brickX;b.y=brickY; ctx.fillStyle=b.powerUp?"#ff9933":"#2f9eff"; roundRect(ctx,brickX,brickY,brickWidth,brickHeight,4); ctx.fill(); if(b.powerUp){ ctx.fillStyle="#072227"; ctx.font="18px Arial"; ctx.fillText(POWER_UP_ICONS[b.powerUp],brickX+brickWidth/2,brickY+brickHeight/2); }}}}}
function drawFallingPowerUps(){ ctx.font="22px Arial"; ctx.textAlign="center"; ctx.textBaseline="middle"; for(const pu of fallingPowerUps){ ctx.beginPath(); ctx.arc(pu.x,pu.y,16,0,Math.PI*2); ctx.fillStyle="rgba(255,255,255,0.06)"; ctx.fill(); ctx.closePath(); ctx.fillStyle="#fff"; ctx.fillText(POWER_UP_ICONS[pu.type],pu.x,pu.y+1); } }
function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

function collisionDetection(ball){ for(let c=0;c<brickColumnCount;c++){ for(let r=0;r<brickRowCount;r++){ const b=bricks[c][r]; if(b.status===1){ if(ball.x+ball.radius>b.x && ball.x-ball.radius<b.x+brickWidth && ball.y+ball.radius>b.y && ball.y-ball.radius<b.y+brickHeight){ const overlapX=Math.min(b.x+brickWidth-(ball.x-ball.radius),(ball.x+ball.radius)-b.x); const overlapY=Math.min(b.y+brickHeight-(ball.y-ball.radius),(ball.y+ball.radius)-b.y); if(!throughBallActive){ if(overlapX<overlapY) ball.dx*=-1; else ball.dy*=-1; } b.status=0; score+=100; if(b.powerUp) spawnPowerUp(b.x+brickWidth/2,b.y+brickHeight/2,b.powerUp); }}}}}

function applyPowerUp(type){ if(type===POWER_UP_TYPES.MULTI_BALL){ const base=balls[0]||createBall(true); const b1=createBall(true); const b2=createBall(true); b1.x=base.x;b1.y=base.y;b1.dx=-Math.abs(base.dx);b1.dy=-Math.abs(base.dy); b2.x=base.x;b2.y=base.y;b2.dx=Math.abs(base.dx); b2.dy=-Math.abs(base.dy)-1; balls.push(b1,b2);} if(type===POWER_UP_TYPES.BIG_PADDLE){ bigPaddleActive=true; effectTimers.big=Date.now(); const center=paddleX+paddleWidth/2; paddleWidth=Math.min(220,paddleWidth*1.6); paddleX=Math.max(6,Math.min(canvas.width-paddleWidth-6,center-paddleWidth/2)); } if(type===POWER_UP_TYPES.THROUGH_BALL){ throughBallActive=true; effectTimers.through=Date.now(); } if(type===POWER_UP_TYPES.SLOW_BALL){ slowBallActive=true; effectTimers.slow=Date.now(); } }
function updateEffects(){ const now=Date.now(); if(bigPaddleActive && now-effectTimers.big>EFFECT_DURATION){ bigPaddleActive=false; const center=paddleX+paddleWidth/2; paddleWidth=DEFAULT_PADDLE_WIDTH; paddleX=Math.max(6,Math.min(canvas.width-paddleWidth-6,center-paddleWidth/2)); } if(throughBallActive && now-effectTimers.through>EFFECT_DURATION) throughBallActive=false; if(slowBallActive && now-effectTimers.slow>EFFECT_DURATION) slowBallActive=false; }

function update(){ ctx.clearRect(0,0,canvas.width,canvas.height); drawScore(); drawBricks(); drawPaddle();

if(gameOver){ ctx.font="40px Arial"; ctx.fillStyle="#ff4444"; ctx.textAlign="center"; ctx.fillText("GAME OVER",canvas.width/2,canvas.height/2); ctx.font="20px Arial"; ctx.fillText("Press SPACE to restart",canvas.width/2,canvas.height/2+40); requestAnimationFrame(update); return; }

if(!gameStarted){ balls.forEach(b=>{ b.x=paddleX+paddleWidth/2; b.y=paddleY-b.radius-4; drawBall(b); }); ctx.font="22px Inter, Arial"; ctx.fillStyle="#e6eef8"; ctx.textAlign='center'; ctx.fillText("Press SPACE to start",canvas.width/2,canvas.height/2); drawFallingPowerUps(); requestAnimationFrame(update); return; }

if(rightPressed && paddleX<canvas.width-paddleWidth-6) paddleX+=paddleSpeed;
if(leftPressed && paddleX>6) paddleX-=paddleSpeed;

for(let i=balls.length-1;i>=0;i--){ const ball=balls[i]; drawBall(ball); if(!ball.active) continue; if(ball.x+ball.dx>canvas.width-ball.radius||ball.x+ball.dx<ball.radius) ball.dx*=-1; if(ball.y+ball.dy<ball.radius) ball.dy*=-1; if(ball.y+ball.radius+ball.dy>paddleY){ if(ball.x>paddleX && ball.x<paddleX+paddleWidth){ const hit=(ball.x-(paddleX+paddleWidth/2))/(paddleWidth/2); const speed=Math.hypot(ball.dx,ball.dy); const angle=hit*(Math.PI/3); ball.dx=speed*Math.sin(angle); ball.dy=-Math.abs(speed*Math.cos(angle)); } } ball.x+=ball.dx*(slowBallActive?0.6:1); ball.y+=ball.dy*(slowBallActive?0.6:1); if(ball.y-ball.radius>canvas.height){ balls.splice(i,1); if(balls.length===0){ lives--; if(lives<=0){ gameOver=true; } else { balls.push(createBall(false)); gameStarted=false; } } continue; } collisionDetection(ball); }

for(let i=fallingPowerUps.length-1;i>=0;i--){ const pu=fallingPowerUps[i]; pu.y+=pu.dy; if(pu.y>paddleY && pu.x>paddleX && pu.x<paddleX+paddleWidth && pu.y<paddleY+paddleHeight+10){ applyPowerUp(pu.type); fallingPowerUps.splice(i,1); continue; } if(pu.y>canvas.height+30) fallingPowerUps.splice(i,1); }

drawFallingPowerUps(); updateEffects();

if(bricks.every(c=>c.every(b=>b.status===0))){ stage++; initBricks(); balls=[createBall(false)]; gameStarted=false; fallingPowerUps=[]; }

ctx.textAlign='start'; requestAnimationFrame(update);
}
requestAnimationFrame(update);
</script>
</body>
</html>
